// Private Renovation Budget Manager - Enhanced Version
// Tech Stack: Vite + Vanilla JS + TypeScript + wagmi + RainbowKit + Tailwind CSS + Radix UI

// Contract configuration
const CONTRACT_ADDRESS = '0x301258156b7D06e69A2E116fc8EC574B78D2EA38';
const SEPOLIA_CHAIN_ID = '0xaa36a7'; // Sepolia testnet chain ID
const SEPOLIA_NETWORK = {
    chainId: SEPOLIA_CHAIN_ID,
    chainName: 'Sepolia Testnet',
    nativeCurrency: {
        name: 'ETH',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: ['https://sepolia.infura.io/v3/'],
    blockExplorerUrls: ['https://sepolia.etherscan.io/']
};

const CONTRACT_ABI = [
    {
        "inputs": [{"internalType": "address[]", "name": "_pauserAddresses", "type": "address[]"}, {"internalType": "uint256", "name": "_kmsGeneration", "type": "uint256"}],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"indexed": true, "internalType": "address", "name": "contractor", "type": "address"}
        ],
        "name": "BidSubmitted",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"indexed": true, "internalType": "address", "name": "homeowner", "type": "address"}
        ],
        "name": "BudgetCalculated",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "address", "name": "contractor", "type": "address"}
        ],
        "name": "ContractorVerified",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"indexed": true, "internalType": "address", "name": "selectedContractor", "type": "address"}
        ],
        "name": "ProjectApproved",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"indexed": true, "internalType": "address", "name": "homeowner", "type": "address"}
        ],
        "name": "ProjectCreated",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"indexed": false, "internalType": "uint8", "name": "roomIndex", "type": "uint8"}
        ],
        "name": "RoomAdded",
        "type": "event"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"internalType": "uint32", "name": "area", "type": "uint32"},
            {"internalType": "uint32", "name": "materialCost", "type": "uint32"},
            {"internalType": "uint32", "name": "laborCost", "type": "uint32"}
        ],
        "name": "addRoomRequirement",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"internalType": "address", "name": "selectedContractor", "type": "address"}
        ],
        "name": "approveProject",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"internalType": "uint32", "name": "contingencyPercent", "type": "uint32"}
        ],
        "name": "calculateBudget",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "createProject",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint256", "name": "projectId", "type": "uint256"}],
        "name": "getBudgetEstimate",
        "outputs": [
            {"internalType": "euint64", "name": "totalBudget", "type": "uint256"},
            {"internalType": "euint64", "name": "finalEstimate", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"internalType": "address", "name": "contractor", "type": "address"}
        ],
        "name": "getContractorBid",
        "outputs": [
            {"internalType": "euint64", "name": "bidAmount", "type": "uint256"},
            {"internalType": "euint32", "name": "timeEstimate", "type": "uint256"},
            {"internalType": "bool", "name": "isSubmitted", "type": "bool"},
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"}
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint256", "name": "projectId", "type": "uint256"}],
        "name": "getProjectContractors",
        "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint256", "name": "projectId", "type": "uint256"}],
        "name": "getProjectInfo",
        "outputs": [
            {"internalType": "address", "name": "homeowner", "type": "address"},
            {"internalType": "bool", "name": "isCalculated", "type": "bool"},
            {"internalType": "bool", "name": "isApproved", "type": "bool"},
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
            {"internalType": "uint8", "name": "roomCount", "type": "uint8"},
            {"internalType": "uint256", "name": "bidCount", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "nextProjectId",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "projectId", "type": "uint256"},
            {"internalType": "uint64", "name": "bidAmount", "type": "uint64"},
            {"internalType": "uint32", "name": "timeEstimate", "type": "uint32"}
        ],
        "name": "submitBid",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "address", "name": "contractor", "type": "address"}],
        "name": "verifyContractor",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "verifiedContractors",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "view",
        "type": "function"
    }
];

// Global variables
let provider;
let signer;
let contract;
let userAddress;
let transactionHistory = [];

// Transaction history management
const TX_STORAGE_KEY = 'renovation_tx_history';

// Load transaction history from localStorage
function loadTransactionHistory() {
    try {
        const stored = localStorage.getItem(TX_STORAGE_KEY);
        if (stored) {
            transactionHistory = JSON.parse(stored);
        }
    } catch (error) {
        console.error('Error loading transaction history:', error);
        transactionHistory = [];
    }
}

// Save transaction history to localStorage
function saveTransactionHistory() {
    try {
        localStorage.setItem(TX_STORAGE_KEY, JSON.stringify(transactionHistory));
    } catch (error) {
        console.error('Error saving transaction history:', error);
    }
}

// Add transaction to history
function addToHistory(type, description, txHash, status = 'pending') {
    const transaction = {
        id: Date.now(),
        type,
        description,
        txHash,
        status,
        timestamp: new Date().toISOString(),
        explorerUrl: `https://sepolia.etherscan.io/tx/${txHash}`
    };

    transactionHistory.unshift(transaction);

    // Keep only last 50 transactions
    if (transactionHistory.length > 50) {
        transactionHistory = transactionHistory.slice(0, 50);
    }

    saveTransactionHistory();
    updateTransactionHistoryUI();
}

// Update transaction status
function updateTransactionStatus(txHash, status, error = null) {
    const tx = transactionHistory.find(t => t.txHash === txHash);
    if (tx) {
        tx.status = status;
        if (error) {
            tx.error = error;
        }
        saveTransactionHistory();
        updateTransactionHistoryUI();
    }
}

// Display transaction history
function updateTransactionHistoryUI() {
    const historyContainer = document.getElementById('transaction-history');
    if (!historyContainer) return;

    if (transactionHistory.length === 0) {
        historyContainer.innerHTML = '<p class="text-gray-500">No transactions yet</p>';
        return;
    }

    const html = transactionHistory.map(tx => `
        <div class="transaction-item ${tx.status}" data-tx-id="${tx.id}">
            <div class="tx-header">
                <span class="tx-type">${tx.type}</span>
                <span class="tx-status ${tx.status}">${getStatusIcon(tx.status)} ${tx.status}</span>
            </div>
            <div class="tx-description">${tx.description}</div>
            <div class="tx-footer">
                <span class="tx-time">${formatTimeAgo(tx.timestamp)}</span>
                <a href="${tx.explorerUrl}" target="_blank" rel="noopener noreferrer" class="tx-link">
                    View on Explorer →
                </a>
            </div>
            ${tx.error ? `<div class="tx-error">${tx.error}</div>` : ''}
        </div>
    `).join('');

    historyContainer.innerHTML = html;
}

// Get status icon
function getStatusIcon(status) {
    switch(status) {
        case 'pending': return '⏳';
        case 'success': return '✅';
        case 'failed': return '❌';
        default: return '•';
    }
}

// Format time ago
function formatTimeAgo(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diff = now - time;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return `${seconds}s ago`;
}

// Enhanced loading state
let loadingStack = 0;

function showLoading(show, message = 'Processing transaction...') {
    if (show) {
        loadingStack++;
        document.getElementById('loading').style.display = 'flex';
        document.getElementById('loading').querySelector('p').textContent = message;
    } else {
        loadingStack = Math.max(0, loadingStack - 1);
        if (loadingStack === 0) {
            document.getElementById('loading').style.display = 'none';
        }
    }
}

// Enhanced error handling
function handleError(error, context = '') {
    console.error(`Error in ${context}:`, error);

    let userMessage = 'An unexpected error occurred. Please try again.';

    // Parse common error messages
    if (error.message) {
        if (error.message.includes('user rejected')) {
            userMessage = 'Transaction cancelled by user.';
        } else if (error.message.includes('insufficient funds')) {
            userMessage = 'Insufficient funds to complete this transaction.';
        } else if (error.message.includes('not authorized') || error.message.includes('Not authorized')) {
            userMessage = 'You are not authorized to perform this action.';
        } else if (error.message.includes('already')) {
            userMessage = error.message;
        } else if (error.message.includes('MetaMask')) {
            userMessage = 'MetaMask error: ' + error.message;
        } else if (error.reason) {
            userMessage = error.reason;
        } else {
            userMessage = error.message;
        }
    }

    showResult(userMessage, 'error');
    return userMessage;
}

// Initialize the application
async function init() {
    if (typeof window.ethereum !== 'undefined') {
        console.log('MetaMask detected');
        loadTransactionHistory();
        updateTransactionHistoryUI();
    } else {
        showResult('Please install MetaMask to use this application. Visit https://metamask.io', 'error');
    }
}

// Add/Switch to Sepolia network
async function addSepoliaNetwork() {
    try {
        await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [SEPOLIA_NETWORK]
        });
    } catch (error) {
        throw new Error('Failed to add Sepolia network: ' + error.message);
    }
}

// Switch to Sepolia network
async function switchToSepolia() {
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: SEPOLIA_CHAIN_ID }]
        });
    } catch (error) {
        if (error.code === 4902) {
            await addSepoliaNetwork();
        } else {
            throw error;
        }
    }
}

// Connect to MetaMask wallet
async function connectWallet() {
    try {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not detected. Please install MetaMask extension from https://metamask.io');
        }

        showLoading(true, 'Connecting to wallet...');

        await window.ethereum.request({ method: 'eth_requestAccounts' });

        provider = new ethers.BrowserProvider(window.ethereum);
        signer = await provider.getSigner();
        userAddress = await signer.getAddress();

        const network = await provider.getNetwork();

        if (network.chainId !== 11155111n) {
            showLoading(true, 'Switching to Sepolia network...');
            await switchToSepolia();
            provider = new ethers.BrowserProvider(window.ethereum);
            signer = await provider.getSigner();
        }

        if (CONTRACT_ADDRESS && ethers.isAddress(CONTRACT_ADDRESS)) {
            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
            document.getElementById('contract-address').textContent = CONTRACT_ADDRESS;
            document.getElementById('deployment-section').style.display = 'none';
            await checkUserRole();
        } else {
            contract = null;
            document.getElementById('contract-address').textContent = 'Contract not deployed';
            document.getElementById('user-role').textContent = 'Please deploy contract first';
            document.getElementById('deployment-section').style.display = 'block';
        }

        document.getElementById('status-text').textContent = `Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
        document.getElementById('connect-btn').style.display = 'none';
        document.getElementById('app-content').style.display = 'block';

        if (CONTRACT_ADDRESS) {
            showResult('✅ Connected to Sepolia successfully!', 'success');
        } else {
            showResult('⚠️ Connected to Sepolia! Please deploy the contract.', 'warning');
        }

    } catch (error) {
        handleError(error, 'connectWallet');
    } finally {
        showLoading(false);
    }
}

// Check user role in the contract
async function checkUserRole() {
    try {
        const owner = await contract.owner();
        const isVerifiedContractor = await contract.verifiedContractors(userAddress);

        let role = 'Homeowner';
        if (userAddress.toLowerCase() === owner.toLowerCase()) {
            role = 'Contract Owner';
        } else if (isVerifiedContractor) {
            role = 'Verified Contractor';
        }

        document.getElementById('user-role').textContent = role;
    } catch (error) {
        console.error('Error checking user role:', error);
        document.getElementById('user-role').textContent = 'Unknown';
    }
}

// Switch between tabs
function switchTab(tabName) {
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    event.target.classList.add('active');
    document.getElementById(`${tabName}-tab`).classList.add('active');
}

// Create a new renovation project
async function createProject() {
    try {
        checkContractAvailable();
        showLoading(true, 'Creating project...');

        const tx = await contract.createProject();
        addToHistory('Create Project', 'Creating new renovation project', tx.hash, 'pending');

        showLoading(true, 'Waiting for confirmation...');
        const receipt = await tx.wait();

        const event = receipt.logs.find(log => {
            try {
                const parsedLog = contract.interface.parseLog(log);
                return parsedLog.name === 'ProjectCreated';
            } catch {
                return false;
            }
        });

        if (event) {
            const parsedEvent = contract.interface.parseLog(event);
            const projectId = parsedEvent.args.projectId.toString();
            updateTransactionStatus(tx.hash, 'success');
            showResult(`✅ Project created successfully! Project ID: ${projectId}`, 'success');
        } else {
            updateTransactionStatus(tx.hash, 'success');
            showResult('✅ Project created successfully!', 'success');
        }

    } catch (error) {
        const errorMsg = handleError(error, 'createProject');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// Add room requirements to a project
async function addRoom() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('project-id').value;
        const area = document.getElementById('room-area').value;
        const materialCost = document.getElementById('material-cost').value;
        const laborCost = document.getElementById('labor-cost').value;

        if (!projectId || !area || !materialCost || !laborCost) {
            throw new Error('Please fill in all fields');
        }

        showLoading(true, 'Adding room to project...');

        const tx = await contract.addRoomRequirement(
            projectId,
            parseInt(area),
            parseInt(materialCost),
            parseInt(laborCost)
        );

        addToHistory('Add Room', `Adding room to project #${projectId}`, tx.hash, 'pending');
        showLoading(true, 'Waiting for confirmation...');
        await tx.wait();

        updateTransactionStatus(tx.hash, 'success');
        showResult('✅ Room added successfully!', 'success');

        document.getElementById('room-area').value = '';
        document.getElementById('material-cost').value = '';
        document.getElementById('labor-cost').value = '';

    } catch (error) {
        const errorMsg = handleError(error, 'addRoom');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// Calculate total budget for a project
async function calculateBudget() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('calc-project-id').value;
        const contingency = document.getElementById('contingency').value;

        if (!projectId || !contingency) {
            throw new Error('Please fill in all fields');
        }

        if (parseInt(contingency) > 50) {
            throw new Error('Contingency percentage cannot exceed 50%');
        }

        showLoading(true, 'Calculating budget...');

        const tx = await contract.calculateBudget(projectId, parseInt(contingency));
        addToHistory('Calculate Budget', `Calculating budget for project #${projectId}`, tx.hash, 'pending');

        showLoading(true, 'Waiting for confirmation...');
        await tx.wait();

        updateTransactionStatus(tx.hash, 'success');
        showResult('✅ Budget calculated successfully! Use "Get Budget Estimate" to view the encrypted results.', 'success');

    } catch (error) {
        const errorMsg = handleError(error, 'calculateBudget');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// View project information
async function viewProject() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('view-project-id').value;

        if (!projectId) {
            throw new Error('Please enter a project ID');
        }

        showLoading(true, 'Loading project information...');

        const projectInfo = await contract.getProjectInfo(projectId);

        const result = `
            <div class="result-item">
                <h4>Project #${projectId} Information</h4>
                <p><strong>Homeowner:</strong> ${projectInfo.homeowner}</p>
                <p><strong>Is Calculated:</strong> ${projectInfo.isCalculated ? 'Yes ✅' : 'No ❌'}</p>
                <p><strong>Is Approved:</strong> ${projectInfo.isApproved ? 'Yes ✅' : 'No ❌'}</p>
                <p><strong>Room Count:</strong> ${projectInfo.roomCount}</p>
                <p><strong>Bid Count:</strong> ${projectInfo.bidCount}</p>
                <p><strong>Created:</strong> ${new Date(Number(projectInfo.timestamp) * 1000).toLocaleString()}</p>
            </div>
        `;

        showResult(result);

    } catch (error) {
        handleError(error, 'viewProject');
    } finally {
        showLoading(false);
    }
}

// Get budget estimate (encrypted values)
async function getBudget() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('view-project-id').value;

        if (!projectId) {
            throw new Error('Please enter a project ID');
        }

        showLoading(true, 'Loading budget estimate...');

        const budget = await contract.getBudgetEstimate(projectId);

        const result = `
            <div class="result-item">
                <h4>Budget Estimate (Encrypted)</h4>
                <p><strong>Total Budget Handle:</strong> ${budget.totalBudget.toString()}</p>
                <p><strong>Final Estimate Handle:</strong> ${budget.finalEstimate.toString()}</p>
                <p class="warning">⚠️ Note: These are encrypted values. Use FHE decryption to view actual amounts.</p>
            </div>
        `;

        showResult(result);

    } catch (error) {
        handleError(error, 'getBudget');
    } finally {
        showLoading(false);
    }
}

// Get contractors who bid on project
async function getContractors() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('view-project-id').value;

        if (!projectId) {
            throw new Error('Please enter a project ID');
        }

        showLoading(true, 'Loading contractors...');

        const contractors = await contract.getProjectContractors(projectId);

        let result = `<div class="result-item"><h4>Contractors for Project #${projectId}</h4>`;

        if (contractors.length === 0) {
            result += '<p>No contractors have bid on this project yet.</p>';
        } else {
            result += '<ul>';
            contractors.forEach((contractor, index) => {
                result += `<li>${index + 1}. ${contractor}</li>`;
            });
            result += '</ul>';
        }

        result += '</div>';
        showResult(result);

    } catch (error) {
        handleError(error, 'getContractors');
    } finally {
        showLoading(false);
    }
}

// Approve project and select contractor
async function approveProject() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('approve-project-id').value;
        const contractorAddress = document.getElementById('selected-contractor').value;

        if (!projectId || !contractorAddress) {
            throw new Error('Please fill in all fields');
        }

        if (!ethers.isAddress(contractorAddress)) {
            throw new Error('Invalid contractor address');
        }

        showLoading(true, 'Approving project...');

        const tx = await contract.approveProject(projectId, contractorAddress);
        addToHistory('Approve Project', `Approving project #${projectId}`, tx.hash, 'pending');

        showLoading(true, 'Waiting for confirmation...');
        await tx.wait();

        updateTransactionStatus(tx.hash, 'success');
        showResult(`✅ Project #${projectId} approved with contractor ${contractorAddress}!`, 'success');

    } catch (error) {
        const errorMsg = handleError(error, 'approveProject');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// Submit a bid (contractor function)
async function submitBid() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('bid-project-id').value;
        const bidAmount = document.getElementById('bid-amount').value;
        const timeEstimate = document.getElementById('time-estimate').value;

        if (!projectId || !bidAmount || !timeEstimate) {
            throw new Error('Please fill in all fields');
        }

        showLoading(true, 'Submitting bid...');

        const tx = await contract.submitBid(
            projectId,
            parseInt(bidAmount),
            parseInt(timeEstimate)
        );

        addToHistory('Submit Bid', `Submitting bid for project #${projectId}`, tx.hash, 'pending');
        showLoading(true, 'Waiting for confirmation...');
        await tx.wait();

        updateTransactionStatus(tx.hash, 'success');
        showResult('✅ Bid submitted successfully!', 'success');

        document.getElementById('bid-amount').value = '';
        document.getElementById('time-estimate').value = '';

    } catch (error) {
        const errorMsg = handleError(error, 'submitBid');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// View contractor's own bid
async function viewMyBid() {
    try {
        checkContractAvailable();

        const projectId = document.getElementById('my-bid-project-id').value;

        if (!projectId) {
            throw new Error('Please enter a project ID');
        }

        showLoading(true, 'Loading your bid...');

        const bid = await contract.getContractorBid(projectId, userAddress);

        const result = `
            <div class="result-item">
                <h4>My Bid for Project #${projectId}</h4>
                <p><strong>Bid Amount Handle:</strong> ${bid.bidAmount.toString()}</p>
                <p><strong>Time Estimate Handle:</strong> ${bid.timeEstimate.toString()}</p>
                <p><strong>Is Submitted:</strong> ${bid.isSubmitted ? 'Yes ✅' : 'No ❌'}</p>
                <p><strong>Submitted:</strong> ${Number(bid.timestamp) > 0 ? new Date(Number(bid.timestamp) * 1000).toLocaleString() : 'Not submitted'}</p>
                <p class="warning">⚠️ Note: Bid amounts are encrypted. Use FHE decryption to view actual values.</p>
            </div>
        `;

        showResult(result);

    } catch (error) {
        handleError(error, 'viewMyBid');
    } finally {
        showLoading(false);
    }
}

// Verify contractor (admin function)
async function verifyContractor() {
    try {
        checkContractAvailable();

        const contractorAddress = document.getElementById('contractor-address').value;

        if (!contractorAddress) {
            throw new Error('Please enter a contractor address');
        }

        if (!ethers.isAddress(contractorAddress)) {
            throw new Error('Invalid contractor address');
        }

        showLoading(true, 'Verifying contractor...');

        const tx = await contract.verifyContractor(contractorAddress);
        addToHistory('Verify Contractor', `Verifying contractor ${contractorAddress}`, tx.hash, 'pending');

        showLoading(true, 'Waiting for confirmation...');
        await tx.wait();

        updateTransactionStatus(tx.hash, 'success');
        showResult(`✅ Contractor ${contractorAddress} verified successfully!`, 'success');

        document.getElementById('contractor-address').value = '';

    } catch (error) {
        const errorMsg = handleError(error, 'verifyContractor');
        if (transactionHistory[0]?.status === 'pending') {
            updateTransactionStatus(transactionHistory[0].txHash, 'failed', errorMsg);
        }
    } finally {
        showLoading(false);
    }
}

// Utility functions
function checkContractAvailable() {
    if (!contract) {
        throw new Error('Contract not deployed. Please deploy the contract and update CONTRACT_ADDRESS in app.js');
    }
}

function showResult(message, type = 'info') {
    const resultsDiv = document.getElementById('results');
    const className = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : '';

    if (typeof message === 'string') {
        resultsDiv.innerHTML = `<div class="${className}">${message}</div>`;
    } else {
        resultsDiv.innerHTML = message;
    }

    resultsDiv.scrollIntoView({ behavior: 'smooth' });
}

// Handle MetaMask account changes
if (typeof window.ethereum !== 'undefined') {
    window.ethereum.on('accountsChanged', (accounts) => {
        if (accounts.length === 0) {
            location.reload();
        } else {
            location.reload();
        }
    });

    window.ethereum.on('chainChanged', (chainId) => {
        location.reload();
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', init);
